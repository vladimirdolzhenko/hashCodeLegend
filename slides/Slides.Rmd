---
title: 'Urban Legend: HashCode'
author: 'Владимир Долженко, IHS Markit'
output:
  ioslides_presentation:
    widescreen: true
    css: slidesstyles.css
---
<div class="footer"></div>
```{r setup, include=FALSE}
library(gdata)
library(ggplot2)

knitr::opts_chunk$set(echo = FALSE)
```
## Ассоциативный массив
<embed src="pair.svg" type="image/svg+xml" />

примеры: 

  * словарь
  * телефонный справочник
  * подсчёт слов в статье
  * и т.д.

## Ассоциативный массив: put(key1, value1)

<embed src="list-pair1.svg" type="image/svg+xml" />

## Ассоциативный массив: put(key2, value2)

<embed src="list-pair2.svg" type="image/svg+xml" />

## Ассоциативный массив: put(key3, value3)

<embed src="list-pair3.svg" type="image/svg+xml" />

## Ассоциативный массив: get(key3)

<embed src="list-pair3-get.svg" type="image/svg+xml" />

## Можно ли лучше ?

<embed src="hash.svg" type="image/svg+xml" />

## javadoc:
### java.lang.Object

`public int hashCode()`

Returns a hash code value for the object. This method is
supported for the benefit of hash tables such as those
provided by **HashMap**.

// ...

[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)


## hashCode и equals

 * **Симметричность**:
    + для ∀ **a** ≠ *null* и ∀ **b** ≠ *null*: **a**.equals(**b**) ⇔ **b**.equals(**a**)
 * **Рефлексивность**:
    + для ∀ **a** ≠ *null* ⇒ **a**.equals(**a**)
 * **Транзитивность**:
    + eсли **a**.equals(**b**) и **b**.equals(**c**) ⇒ **a**.equals(**c**)
 * **Совместимость** с hashCode():
    + если **a**.equals(**b**) ⇒ **a**.hashCode() == **b**.hashCode()

## hashMap.put( key1, value1 )

<embed src="hashtable-put.svg" type="image/svg+xml" />

## hashMap.get( key1 )

<embed src="hashtable-get.svg" type="image/svg+xml" />

## hashMap.get( key2 )

<embed src="hashtable-get-null.svg" type="image/svg+xml" />

## Контракт hashCode

- неизменчивость и постоянство

```
Whenever it is invoked on the same object more than once during
an execution of a Java application, the hashCode method must
consistently return the same integer, provided no information
used in equals comparisons on the object is modified.

...
```
[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)

## нарушение контракта hashCode

<embed src="hashtable-broken.svg" type="image/svg+xml" />

## Сложность поиска / вставки

<embed src="hashtable-complexity.svg" type="image/svg+xml" />

## Коллизии

<embed src="hashtable-collisions.svg" type="image/svg+xml" />

## Разрешение коллизий - chaining

<embed src="hashtable-collisions-chaining.svg" type="image/svg+xml" />

## свойства hashCode

- неизменчивость и постоянство
- *хорошее* распределение == меньше коллизий

## Object.hashCode - утёкшая абстракция

```java
Object object = new Object();

assert object.hashCode() == System.identityHashCode(object);

```

## Urban Legend: Первоисточник
### java.lang.Object

`public int hashCode()`

// ...

_This is typically implemented by converting the **internal address of the object** into an integer, but this implementation technique is not required by the JavaTM programming language._

[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)


## Urban Legend:

```java
package java.lang;

public class Object {

    // ...

    public int hashCode(){
      return &this;
    }

}
```

# sun.misc.Unsafe ?

# Java Object Layout !
```java
VirtualMachine vm = VM.current();
long address = vm.addressOf(object);

long size = vm.sizeOf(object);

for (int offset = 0; offset < size; offset += 4) {
  int dump = vm.getInt(object, offset);
}
```
## ObjectReallocation demo:

```java
Object object = new Object();
long address = getAddress(object);
int hashCode = object.hashCode();

list.add(object);

for(int i = 0; ; i++) {
	Object o = new Object();
	list.add(o);

	long address2 = getAddress(object);

	if (address != address2) {
	  int hashCode2 = object.hashCode();
	  throw new RuntimeException();
	}
}
```

## ObjectReallocation demo:

```java
Object object = new Object();
long address = getAddress(object);

list.add(object);

for(int i = 0; ; i++) {
	Object o = new Object();
	list.add(o);

	long address2 = getAddress(object);

	if (address != address2) {
	  throw new RuntimeException();
	}
}
```

`-verbose:gc -XX:+PrintGC -XX:+PrintGCDetails`

## Object.hashCode() ?
```java
package java.lang;

public class Object {

    // ............

    public native int hashCode();
    
}
```

## ObjectMemoryDump - читаем заголовок

<embed src="header.svg" type="image/svg+xml" />

Intel X86: Little Endian

## ObjectMemoryDump - читаем заголовок

<embed src="header-address.svg" type="image/svg+xml" />
```
```
`-XX:hashCode=4`

## Адресное пространство объекта

<embed src="address.svg" type="image/svg+xml" />

## Упрощённый memory allocation

```c
private char *memory_pointer;

public void * malloc(long size)
{
    char *old = memory_pointer;

    memory_pointer += size;

    return (void *)old;
}
```

## Навалим в кучу

```bash
$ java -XX:+PrintFlagsFinal -version | \
            egrep  "(InitialHeapSize|MaxHeapSize)"

    uintx InitialHeapSize    := 268 435 456
    uintx MaxHeapSize        := 4 294 967 296

java version "1.8.0_112"
```

```java
long freeMemory = Runtime.getRuntime().freeMemory();

239 942 568
```

`239 942 568 / 16 = 14 996 410.5`

→ должно хватить как минимум на **14 млн** объектов

## IdentityHashCodeCollision demo:

```java
Set<Integer> codes = new HashSet<>();
List list = new ArrayList();

for(int i = 0; ; i++){
	Object obj = new Object();
	list.add(obj);

	int hashCode = obj.hashCode();

	if (!codes.add(hashCode))
		throw new RuntimeException();

}
```
```
```
`-XX:hashCode=4`

## ThreadedIdentityHashCodeCollision demo:

```java
new Thread(new Runnable() {
    public void run() {
        for (int i = 0; ; i++) {

            final Object object = new Object();

            synchronized (list) {
                list.add(object);
                int hashCode = object.hashCode();
                if (!codes.add(hashCode))
                    throw new RuntimeException();
            }
        }
    }
}).start();
```
`-XX:hashCode=4`


## Немного исправленный наивный malloc 

* нужен `synchronized` или `Compare-And-Swap`

```c
private char *memory_pointer;

public synchronized void * malloc(long size)
{
    char *old = memory_pointer;

    memory_pointer += size;

    return (void *)old;
}
```

⇒ высокий `contention` при аллокации

## Thread Local Allocation Buffer

<embed src="tlab.svg" type="image/svg+xml" />

## IdentityHashCodeCollision demo:

```java
Set<Integer> codes = new HashSet<>();
List list = new ArrayList();

for(int i = 0; ; i++){
	Object obj = new Object();
	list.add(obj);

	int hashCode = obj.hashCode();

	if (!codes.add(hashCode))
		throw new RuntimeException();

}
```
```
```
`-XX:hashCode=4 -XX:+PrintTLAB`

## Стоимость TLAB

```java
    @Benchmark
    public Object allocate() {
       return new Object();
    }
```

## Стоимость TLAB

```java
    @Benchmark
    public Object allocate() {
       return new Object();
    }
```

 Benchmark               | Opts     | Score   | Error  | Units
--|--|--|--|--
 AllocationPerfTest.allocate | -XX:+UseTLAB | <span class="good">4.155</span> | 0.090 | ns/op
 AllocationPerfTest.allocate | -XX:-UseTLAB | <span class="bad">11.939</span> | 0.277 | ns/op

```
```

**TLAB** → 3x быстрее аллокация

# Object.hashCode: кто же ты ?

## -XX:hashCode

-XX:hashCode=k | Тип
---------------|----------
  0 | <span class="good">[Park-Miller генератор случайных чисел](https://en.wikipedia.org/wiki/Lehmer_random_number_generator), </span> *по умолчанию*
  1 | <span class="bad">fn(адрес объекта, глобальное состояние)</span>
  2 | <span class="bad">константа 1</span>
  3 | <span class="good">последовательный счетчик</span>
  4 | <span class="bad">адрес объекта</span>
  5 | Thread-local Xorshift</span>

## Распределение identity hashCode
10 млн объектов в 10 нитях:
```{r  fig.width=10, fig.height=5, echo = FALSE}
addressHashCode = read.csv(file = "addressHashCode.csv", header = TRUE)
defaultHashCode = read.csv(file = "defaultHashCode.csv", header = TRUE)

ggplot(alpha=0.3) +
  geom_histogram(data=addressHashCode, aes(x=hashCode, fill="address"), alpha=0.3, bins = 500) +
  geom_histogram(data=defaultHashCode, aes(x=hashCode, fill="PMRng"), alpha=0.3, bins = 500) +
  scale_fill_manual(name="hashCode type:", labels=c("address"="address", "PMRng"="PMRng"), values=c("address" = "red", "PMRng"="blue")) +
  labs(title =
         sprintf("address collisions: %s k, PMrng collisions: %s k",
                 round( sum(duplicated(addressHashCode)) / 1000, 1),
                 round( sum(duplicated(defaultHashCode)) / 1000, 1)),
       x = "hashCode",
       y = "Count")+
  scale_y_continuous(labels=scales::comma) +
  scale_x_continuous(labels=scales::comma) +
  theme(aspect.ratio = 9/16)
```

## Плохой выбор 

Использование адреса в качестве hashCode

* объекты перемещаются 
* много коллизий
* адреса выравнены → сужение вариантов

# Beyond the legend

## Функции масштабирования

* `hashCode % array.length`
    + `array.length` - простое число, исп. *Trove*

## Функции масштабирования
    
* `hashCode & mask`
    + исп. *Java Collections*, *Koloboke* и д.р.
    
если `array.length` = 2<sup>k</sup>
<embed src="mod.svg" type="image/svg+xml" />

`hashCode % array.length = hashCode & (array.length - 1)`


## hashCode() и данные

```java
String s1 = new String("java");

String s2 = new String("java");

assert s1.hashCode() == s2.hashCode();

Integer i1 = new Integer(42);

Integer i2 = new Integer(42);

assert i1.hashCode() == i2.hashCode();
```


## простой hashCode

```java
public class Point {
    public int x, y;

    @Override
    public int hashCode(){
        return 31 * x + y;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point)) return false;

        Point point = (Point) o;

        return x == point.x && y == point.y;
    }
}
```

## типичный hashCode

```java
public final class String {
    private final char value[];
    private int hash;

    public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
}
```

# Парадокс дней рождений

## Парадокс дней рождений

```{r fig.width=10, fig.height=5, echo = FALSE}
birthdays = read.csv(file = "birthdays.csv", header = TRUE)

ggplot(data=birthdays, aes(x=N, y=probability)) +
    geom_line() +
  labs(x = "N",
       y = "probability, %")+
    geom_point()

# [Wolfram Alpha](https://www.wolframalpha.com/input/?i=plot+(100+-+100+*+(+365!+%2F+(365%5En+*+(365-n)!))+where+n+%3D+%5B1,100%5D))

```

## Парадокс дней рождений для hashCode

$$p_{uniq}(n) = \left({1 - \frac{1}{2^{32}}}\right)\cdot\left({1 - \frac{2}{2^{32}}}\right)\cdot\ldots\cdot\left({1 - \frac{n - 1}{2^{32}}}\right) =$$
$$ = \frac{2^{32}}{2^{32 n} \cdot (2^{32} - n)!}$$


$$ \Rightarrow 1 - p_{uniq}(n) \approx 0.5, при \  n = 77\ 170$$

[Wolfram Alpha](https://www.wolframalpha.com/input/?i=100+-+100+*+(+(2%5E32)!+%2F+(2%5E(32*77170)+*+(2%5E32-77170)!)))

$$ \Rightarrow 1 - p_{uniq}(n) \approx 0.99, при\ n = 200\ 000$$
[Wolfram Alpha](https://www.wolframalpha.com/input/?i=100+-+100+*+(+(2%5E32)!+%2F+(2%5E(32*200000)+*+(2%5E32-200000)!)))

## далеко ходить не надо

```java
assert "Aa".hashCode() == "BB".hashCode();
```


## Comparable
```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```
например:

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    ///
}
```

```java
public final class Integer extends Number
    implements Comparable<Integer> {
    ///
}
```

*и другие...*

## Бинарное дерево поиска

<embed src="hashtable-collisions-rbtree.svg" type="image/svg+xml" />

## Low contention - Biased Locking

<embed src="biasedlocking.svg" type="image/svg+xml" />

## Biased Locking demo:

```java
        Object object = new Object();

        String dump0 = dump(object);

        final List list = new ArrayList();

        synchronized (object) {
            list.add(object);
        }

        String dump1 = dump(object);

        int hashCode = System.identityHashCode(object);

        String dump2 = dump(object);
```
`-XX:BiasedLockingStartupDelay=0`

## Biased Locking demo:

<embed src="header-biasedlocking.svg" type="image/svg+xml" />
`-XX:BiasedLockingStartupDelay=0`

## Biased Locking - Counter:
```java
    public class Counter {
        private long count = 0l;
        
        public synchronized long incAndGet() {
            return ++count;
        }
    }

```

## BiasedLockingPerfTest

```java
Counter counter, counterWithSysIdHashCode;

@Benchmark
public long increment() {
    return counter.incAndGet();
}

@Benchmark
public long incrementWithSysIdHashCode() {
    return counterWithSysIdHashCode.incAndGet();
}
    
@Setup
public void setup(Blackhole bh) {
    counter = new Counter();
    counterWithSysIdHashCode = new Counter();
    bh.consume(System.identityHashCode(counterWithSysIdHashCode));
}
```

## BiasedLockingPerfTest результаты

` -XX:+UseBiasedLocking`

  Benchmark                                |  Score   | Error  | Units
  --|--|--|--
  BiasedLockingPerfTest.increment         | <span class="good">5.799</span> | 0.148 | ns/op
  BiasedLockingPerfTest.incrementWithSysIdHashCode | <span class="bad">25.279</span> | 1.054 | ns/op
  
  
`-XX:-UseBiasedLocking`

  | | |
  --|--|--|--
  BiasedLockingPerfTest.increment         | <span class="bad">24.994</span> | 0.895 | ns/op
  BiasedLockingPerfTest.incrementWithSysIdHashCode | <span class="bad">25.121</span> | 0.976 | ns/op


## Заключение

* <span class="good">HashMap</span> - быстро
* HashCode - не <span class="bad">адрес</span>
    + В JVM есть <span class="good">GC</span>, <span class="good">TLAB</span>
* <span class="bad">`System.identityHashCode`</span> - плохо
    + Biased locking
* <span class="good">Переопределяйте `hashCode` и `equals`</span>
    + <span class="good">простые числа</span> для множителей - хорошо
    + <span class="bad">чётные числа</span> для множителей и битовые операции - плохо
* и ещё лучше <span class="good">определяйте `compareTo`</span>

# Q/A

# Контакты


### слайды и примеры: [github.com/vladimirdolzhenko/hashCodeLegend](https://github.com/vladimirdolzhenko/hashCodeLegend)
### email: [vladimir.dolzhenko@gmail.com](mailto:vladimir.dolzhenko@gmail.com)
### twitter: [\@dolzhenko](https://twitter.com/dolzhenko)
