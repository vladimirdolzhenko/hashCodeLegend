---
title: "Внутрь VM сквозь замочную скважину hashCode"
author: 
  name: "Владимир Долженко"
  email: "vladimir.dolzhenko @ gmail.com"
  company: "IHS Markit"
  twitter: "dolzhenko"
  github: "github.com/vladimirdolzhenko/hashCodeLegend"
date: "2017-04-03"
output:
  ioslides_presentation:
    widescreen: true
    self_contained: true
---

<link rel="stylesheet" href="highlight-default.css">
<link rel="stylesheet" href="github-gist.css">
<link rel="stylesheet" href="slidesstyles.css">

<script src="jquery.min.js"></script>
<script src="highlight.pack.js"></script>
<script>
$(document).ready(function() {
  $('pre code').each(function(i, e) {hljs.highlightBlock(e)});
});
</script>
<div class="footer"></div>
```{r setup, include=FALSE}
library(gdata)
library(ggplot2)

Sys.setlocale(category = "LC_ALL", locale = 'UTF-8')

rows = 1000
rows = 10000000

knitr::opts_chunk$set(echo = FALSE)
```

# no warranty

## План {.abstract`r sprintf("%d",rows)`}
* Немного теории
* Правила вычисления hashCode
    + DoS-атака с примененимем hashCode
* HashCode как адрес объекта - миф или реальность
    + JVM потроха: GC и аллокации
    + Немного баттлов про hashCode
* Правильные инструменты: JMH и JOL
* Удешевление блокировок

## Ассоциативный массив / Dictionary / Map {.hash}

![](images/hashtable.svg)

<pre><code class="java">int hash =  hash( key );
int index = Math.abs( hash ) 
       % keys.length;
</code></pre>

## javadoc: {.javadoc}
### java.lang.Object

<pre><code class="java">public int hashCode()</code></pre>

Returns a hash code value for the object. This method is
supported for the benefit of hash tables such as those
provided by **HashMap**.

[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)

## Записать ( Алексей, +79... )

![](images/hashtable-put3.svg)

## Сложность поиска / вставки {.hashCodeComplexity}
<pre><code class="java">String key = "Алексей";

int hash = key.hashCode();
int index = Math.abs( hash ) % keys.length;

if ( key.equals( keys[index] ) ) {
    return values[index];
}
return null;</code></pre>
<span class="huuuge">сложность → <span class="highlight">**O( 1 )**</span></span>

## Контракт hashCode {.javadoc}

- неизменчивость и постоянство

Whenever it is invoked on the same object more than once during
an execution of a Java application, the hashCode method <span class="highlight">must
_consistently_</span> return the <span class="highlight">same integer</span>, provided no information
used in equals comparisons on the object is modified.


[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)


## Нарушение контракта hashCode

![](images/hashtable-broken.svg)

## Коллизии

![](images/hashtable-collisions.svg)

## Chaining {.chaining}

![](images/hashtable-collisions-chaining.svg)
<span class="huuuge">сложность → <span class="highlight">**O( N )**</span></span>

## Открытая адресация

![](images/hashtable-collisions-oa.svg)

## Открытая адресация {.openAddressing}

![](images/hashtable-collisions-oa2.svg)

<span class="huuuge">сложность → <span class="highlight">**O( N )**</span></span>

## hashCode - функция от содержимого объекта {.hashFunctionData}
<pre><code class="java">String s1 = new String("java");
String s2 = new String("java");

assert s1.hashCode() == s2.hashCode(); // <span class="hl">true</span>

Integer i1 = new Integer(42);
Integer i2 = new Integer(42);

assert i1.hashCode() == i2.hashCode(); // <span class="hl">true</span>
</code></pre>

## Полиномиальный hashCode {.polynomHashCode}

```
```

$$ hashCode = \sum_{k=0}^{n} {31^{n-k} \cdot property_k}  $$

## String.hashCode() {.stringHashCode}

<pre><code class="java">public final class String {
    private final char value[];
    private int hash;

    public int hashCode() {
        int h = hash;
        if (h == 0 &amp;&amp; value.length &gt; 0) {
            char val[] = value;

            <span class="hl">for (int i = 0; i < value.length; i++)
                h = 31 * h + val[i]</span>;

            hash = h;
        }
        return h;
    }
}</code></pre>

## String.hashCode - часть public API {.stringHashCode}
<pre><code class="java">public final class String {
  /**
   * Returns a hash code for this string. The hash code
   * for a <span class="code">String</span> object is computed as
   *
   * <span class="hl">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span>
   *
   * using <span class="code">int</span> arithmetic, where <span class="code">s[i]</span>
   * is the <i>i</i>th character of the string,
   * <span class="code">n</span> is the length of the string,
   * and <span class="code">^</span> indicates exponentiation.
   * (The hash value of the empty string is zero.)
   *
   * @return  a hash code value for this object.
   */
    public int hashCode() {        ...      }
}
</code></pre>

## java v.1.1.1 - String.hashCode()
<pre><code class="java">public int hashCode() {
	int h = 0;
	int off = offset;
	char val[] = value;
	int len = count;

	if (len < 16) {
	    for (int i = len ; i > 0; i--) {
		    h = (h * 37) + val[off++];
	    }
	} else {
	    // only sample some characters
	    int skip = len / 8;
	    for (int i = len ; i > 0; i -= skip, off += skip) {
		    h = (h * 39) + val[off];
	    }
	}
	return h;
}</code></pre>

## 31 : Детективная история {.detective31}

* <span class="huge">1997 год (!!!)</span>: [java bug #4045622](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4045622)
    + Все слова и словоформы в словаре Merriam-Webster 2 ред. (311_141 строк, ср. длина 10 символов).
    + Все строки в `/bin/*`, `/usr/bin/*`, `/usr/lib/*`, `/usr/ucb/*` и `/usr/openwin/bin/*`  (66_304 строк, ср. длина 21 символов).
    + Список URL, собранных web-пауком за несколько часов (28_372 строк, ср. длина 49 символов).

<div class="center">полиномы <span class="highlight huuuge">31</span>, <span class="highlight huuuge">33</span>, <span class="highlight huuuge">37</span> → мин. средняя длина коллизий
</div>

## Но ведь можно подобрать... {.AaBB}

<pre><code class="java">assert "Aa".hashCode() 
  == "BB".hashCode();
</code></pre>

$$ 31 \cdot c_0 + c_1 = $$
$$ = 31 \cdot (c_0 - 1) + (c_1 + 31) $$

<div style="text-align: center;">
<span class="huuuge">**`username`**</span> ⟹ <span class="huuuge">499_331</span> <br/>
вариантов коллизий</div>


# Java Microbenchmark Harness {.jmh}
[http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/)

## JMH :: "username" коллизии :: benchmark{.jmhExample}

<pre><code class="java">@State(Scope.Benchmark)
public class MapPerfTest {

  Map map;
  String[] keys;

  @Setup
  public void setup() { ..... }

<div class="hblock"><span class="hl">@Benchmark</span> @Threads( 1 )
public Map fillMap() {
  for (String key : keys)
    map.put(key, key);

  return map;
}</div>
}</code></pre>

## JMH :: "username" коллизии :: benchmark

<pre><code class="java"><span class="hl">@BenchmarkMode(Mode.AverageTime)
@Warmup(iterations = 5, time = 5, timeUnit = SECONDS)
@Measurement(iterations = 5, time = 5, timeUnit = SECONDS)</span>
@State(Scope.Benchmark)
public class MapPerfTest {

  Map map;
  String[] keys;

  @Setup
  public void setup() { ... }

  @Benchmark <span class="hl">@Threads( 1 )</span>
  public Map fillMap() {
    // ...
  }
}</code></pre>

## JMH :: "username" коллизии :: benchmark {.jmhExample}

<pre><code class="java">
@State(Scope.Benchmark)
public class MapPerfTest {

  <span class="hl">@Param</span>( {"1", "1000", "10000", "100000", "200000"})
  int size;
  Map map;
  String[] keys;

<div class="hblock"><span class="hl">@Setup</span>
public void setup() {
  map = new HashMap&lt;String, String&gt;( size );
  keys = <span class="hl">loadUsernameCollisionsFromFile( size )</span>;
}</div>
  @Benchmark @Threads( 1 )
  public Map fillMap() { ... }

}</code></pre>

## "username" коллизии {.usernameCollisionsChart1}

```{r, out.height="600px", out.width="1000px"}

df = read.csv(file = "csv/username.csv", header = TRUE)
df7 <- subset(df, java == "java 7")

d <- transform(df7, time_per_op = time / size, time_sec = time / (10^9))

ggplot(data=d, aes(x=size, y=time_sec, group=java, colour=java)) +
  geom_line(linetype="solid", size=2) +
  geom_point(aes(shape=java),size=6) +
  scale_color_manual(values=c("java 8"="#1fbec3", "java 7"="#f57670")) +
  scale_shape_manual(values=c("java 8"=17, "java 7"=19))+
  scale_y_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  scale_x_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  labs(title = "секунды",
     x = "количество ключей",
     y = "") +
  theme_classic() +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(title = element_text(size = 18, face = "bold")) +
  theme(legend.position="none", aspect.ratio = 0.5)
```

# ещё одна <span class="orthogonal">функция</span> нужна

## Дополнительная функция: compareTo {.rbTree}

![](images/hashtable-collisions-rbtree.svg)

<span class="huuuge">сложность → <span class="highlight">**O( log( N ) )**</span></span>

## Chaining и Красно-Чёрное-Дерево {.chainingRBTree}

![](images/hashtable-collisions-rbtree2.svg)


## "username" коллизии

```{r, out.height="650px", out.width="1000px"}
df = read.csv(file = "csv/username.csv", header = TRUE)
df78 <- subset(df, java == "java 7" | java == "java 8")
d <- transform(df78, time_per_op = time / size, time_sec = time / (10^9))
ggplot(data=d, aes(x=size, y=time_sec, group=java, colour=java)) +
  geom_line(linetype="solid", size=2) +
  geom_point(aes(shape=java),size=6) +
  scale_color_manual(values=c("java 8"="#1fbec3", "java 7"="#f57670")) +
  scale_shape_manual(values=c("java 8"=17, "java 7"=19))+
  scale_y_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  scale_x_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  labs(title = "секунды",
     x = "количество ключей",
     y = "") +
  theme_classic() +
  coord_cartesian(xlim = c(0,200000), ylim = c(0, 115)) +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(axis.title.y=element_text(margin=margin(r=20))) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(title = element_text(size = 18, face = "bold")) +
  theme(aspect.ratio = 0.5)

```


## "username" коллизии :: 500x zoom-in

```{r, out.height="650px", out.width="1000px"}
df = read.csv(file = "csv/username.csv", header = TRUE)

df78 <- subset(df, java == "java 8" | java == 'java 7')

d <- transform(df78, time_per_op = time / size, time_msec = time / (10^6))

ggplot(data=d, aes(x=size, y=time_msec, group=java, colour=java)) +
  geom_line(linetype="solid", size=2) +
  geom_point(aes(shape=java),size=6) +
  scale_color_manual(values=c("java 8"="#1fbec3", "java 7"="#f57670")) +
  scale_shape_manual(values=c("java 8"=17, "java 7"=19))+
  scale_y_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  scale_x_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  labs(title = "миллисекунды",
     x = "количество ключей",
     y = "") +
  theme_classic() +
  coord_cartesian(xlim = c(0,200000), ylim = c(0, 220)) +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(axis.title.y=element_text(margin=margin(r=20))) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(title = element_text(size = 18, face = "bold")) +
  theme(aspect.ratio = 0.5)


```

## "username" коллизии :: java 8 :: map.put(key, *)

```{r, out.height="650px", out.width="1000px"}
df <- read.csv(file = "csv/username.csv", header = TRUE)

df8 <- subset(df, java == "java 8")

d <- transform(df8, time_per_op = time / size, time_ms = time / (10^6), time_sec = time / (10^9))

ggplot(data=d, aes(x=size, y=time_per_op, group=java, colour=java)) +
  geom_line(linetype="solid", size=2) +
  geom_point(aes(shape=java),size=6) +
  scale_color_manual(values=c("java 8"="#1fbec3", "java 7"="#f57670")) +
  scale_shape_manual(values=c("java 8"=17, "java 7"=19))+
  scale_y_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  scale_x_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  labs(title = "наносекунды",
     x = "количество ключей",
     y = "") +
  theme_classic() +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(axis.title.y=element_text(margin=margin(r=20))) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(title = element_text(size = 18, face = "bold")) +
  theme(aspect.ratio = 0.5)


```

## "username" коллизии :: Comparable

```{r, out.height="650px", out.width="1000px"}
df <- read.csv(file = "csv/cmp.csv", header = TRUE)

d <- transform(df, time_per_op = time / size, time_ms = time / (10^6), time_sec = time / (10^9))

ggplot(data=d, aes(x=size, y=time_sec, group=type, colour=type)) +
  geom_line(linetype="solid", size=2) +
  geom_point(aes(shape=type),size=6) +
  scale_color_manual(values=c("comparable"="#1fbec3", "java 7"="#f57670", "non-comparable"="#c987fc")) +
  scale_shape_manual(values=c("comparable"=17, "java 7"=19, "non-comparable"=18))+
  scale_y_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  scale_x_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}) +
  labs(title = "comparable против non-comparable",
     x = "количество ключей",
     y = "секунды") +
  theme_classic() +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(axis.title.y=element_text(margin=margin(r=20))) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(title = element_text(size = 18, face = "bold")) +
  theme(aspect.ratio = 0.6)


```

# Object.hashCode<br/> <span style="margin-left:200px;">утёкшая абстракция</span>

# Urban Legend {.urbanLegendC}

<pre><code class="java">public int hashCode(){
  return <span class="hl">&this</span>;
}</code></pre>

## Urban Legend: Первоисточник  {.javadoc}
### java.lang.Object

<pre><code class="java">public int hashCode()</code></pre>

This is typically implemented by converting the <span class="highlight">internal address of the object</span> into an integer.

[https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--)

# Адрес объекта ?

# native method{.native}
<pre><code class="java">  package java.lang;

  public class Object {

      // ............

      public native int hashCode();
  }</code></pre>

# &nbsp; {.shipilev}

<div class="center">![](images/shipilёv-unsafe.jpg)</div>

## Java Object Layout {.jol}

<pre><code class="java">Object theObject</span> = new Object();

VirtualMachine vm = VM.current();

long address = vm.<span class="hl">addressOf</span>( theObject );

long size = vm.<span class="hl">sizeOf</span>( theObject );

</code></pre>

[http://openjdk.java.net/projects/code-tools/jol/](http://openjdk.java.net/projects/code-tools/jol/)

## JOL : sizeOf( new Pair() ) {.jol0}

<div class="floating-box"><pre><code class="java">class Pair&lt;F, S&gt; {
  F first;
  S second;
}</code></pre></div>
<div class="floating-box"><pre><code class="java">class Pair2&lt;F, S&gt; {
  F first;
  S second;
  <span class="hl">int hashCode</span>;
}</code></pre></div><div style="clear:both"></div>

## -XX:+UseCompressedOops и heap &lt; 4Gb {.jol0}

<div class="line"><code><span class="highlight">-XX:+UseCompressedOops</span></code></div>
<div class="floating-box2"><code><span class="highlight">24 b</span></code></div>
<div class="floating-box2"><code><span class="highlight">24 b</span></code></div>
<div class="clear"></div>

<div class="floating-box"><pre><code class="java">class Pair&lt;F, S&gt; {
  F first;
  S second;
}</code></pre></div>
<div class="floating-box"><pre><code class="java">class Pair2&lt;F, S&gt; {
  F first;
  S second;
  int hashCode;
}</code></pre></div><div class="clear"></div>

## -XX:+UseCompressedOops и heap &lt; 4Gb {.jol2}

<div class="line"><code>-XX:+UseCompressedOops</code></div>
<div class="floating-box2"><code>24 b</code></div>
<div class="floating-box2"><code>24 b</code></div>
<div class="clear"></div>

<div class="floating-box pair"><pre><code class="java">class Pair&lt;F, S&gt; {
  F first;
  S second;
}</code></pre></div>
<div class="floating-box"><pre><code class="java">class Pair2&lt;F, S&gt; {
  F first;
  S second;
  int hashCode;
}</code></pre></div><div class="clear"></div>
<pre><code class="text"><span class="highlight huge">Pair</span> object internals:
<div class="hblock"> OFFSET  SIZE   TYPE DESCRIPTION
      0    12        (object header)
     12     4 Object Pair.first
     16     4 Object Pair.second
     20     <span class="huuge">4</span>      <span class="huuge">(<span class="highlight">loss</span> due to the next</span>
                     <span class="huuge">object alignment)</span>
</div></code></pre>

## -XX:-UseCompressedOops или heap &gt; 4Gb{.jol0}

<div class="line"><code><span class="highlight">-XX:-UseCompressedOops</span></code></div>
<div class="floating-box2"><code><span class="highlight">32 b</span></code></div>
<div class="floating-box2"><code><span class="highlight">40 b</span></code></div>
<div class="clear"></div>

<div class="floating-box"><pre><code class="java">class Pair&lt;F, S&gt; {
  F first;
  S second;
}</code></pre></div>
<div class="floating-box"><pre><code class="java">class Pair2&lt;F, S&gt; {
  F first;
  S second;
  int hashCode;
}</code></pre></div><div class="clear"></div>

## -XX:-UseCompressedOops или heap &gt; 4Gb{.jol2}

<div class="line"><code>-XX:-UseCompressedOops</code></div>
<div class="floating-box2"><code>32 b</code></div>
<div class="floating-box2"><code>40 b</code></div>
<div class="clear"></div>

<div class="floating-box"><pre><code class="java">class Pair&lt;F, S&gt; {
  F first;
  S second;
}</code></pre></div>
<div class="floating-box pair2"><pre><code class="java">class Pair2&lt;F, S&gt; {
  F first;
  S second;
  int hashCode;
}</code></pre></div><div class="clear"></div>
<pre><code class="text"><span class="highlight huge">Pair2</span> object internals:
<div class="hblock"> OFFSET  SIZE   TYPE DESCRIPTION
      0    16        (object header)
     16     4    int Pair2.hashCode
     20     <span class="huuge">4</span>      (<span class="highlight huuge">alignment/padding gap</span>)
     24     8 Object Pair2.first
     32     8 Object Pair2.second
</div></code></pre>

## Адрес и hashCode

![](images/header-address0.svg)

<code><span class="huuge">-XX:<span class="hashCode">hashCode=4</span></span></code>

## Следим за адресом объекта

<pre><code class="java">final Object <span class="hl">theObject</span> = new Object();
final long <span class="hl">initialAddress = getAddress( theObject )</span>;

List gcKeeper = new ArrayList();
gcKeeper.add( theObject );

long currentAddress = initialAddress;
while (initialAddress == currentAddress) {
    Object o = new Object();

    gcKeeper.add( o );

    currentAddress = getAddress( theObject );
}</code></pre>

```-Xms256m -Xmx256m -XX:+UseSerialGC```

## Следим за адресом объекта

<pre><code class="java">final Object theObject = new Object();
final long initialAddress = getAddress( theObject );

<span class="hl">List gcKeeper = new ArrayList();</span>
gcKeeper.add( theObject );

long currentAddress = initialAddress;
while (initialAddress == currentAddress) {
    <span class="hl">Object o = new Object();</span>

    <span class="hl">gcKeeper.add( o );</span>

    currentAddress = getAddress( theObject );
}</code></pre>

```-Xms256m -Xmx256m -XX:+UseSerialGC```

## Следим за адресом объекта

<pre><code class="java">final Object theObject = new Object();
final long initialAddress = getAddress( theObject );

List gcKeeper = new ArrayList();
gcKeeper.add( theObject );

long currentAddress = initialAddress;
<div class="hblock">while (<span class="hl">initialAddress == currentAddress</span>) {
    Object o = new Object();

    gcKeeper.add( o );

    <span class="hl">currentAddress = getAddress( theObject )</span>;
}</div></code></pre>

```-Xms256m -Xmx256m -XX:+UseSerialGC```

## Следим за адресом объекта

<pre><code class="java">final Object theObject = new Object();
final long initialAddress = getAddress( theObject );

List gcKeeper = new ArrayList();
gcKeeper.add( theObject );

long currentAddress = initialAddress;
while (initialAddress == currentAddress) {
    Object o = new Object();

    gcKeeper.add(o);

    currentAddress = getAddress( theObject );
}</code></pre>

<code><span class="highlight">-Xms256m -Xmx256m -XX:+UseSerialGC</span></code>

# demo

## GC: поколения {.generations}

![](images/generations.svg)

GC: Serial / Parallel / CMS

## Следим за адресом объекта вместе с GC

<pre><code class="java">final Object theObject = new Object();
final long initialAddress = getAddress( theObject );

List gcKeeper = new ArrayList();
gcKeeper.add( theObject );

long currentAddress = initialAddress;
while (initialAddress == currentAddress) {
    Object o = new Object();

    gcKeeper.add(o);

    currentAddress = getAddress( theObject );
}</code></pre>

<code><span class="highlight">-XX:+PrintGCDetails</span> -Xmx256m -XX:+UseSerialGC</code>

## GC - не только сборка мусора

![](images/reallocation2.svg)

## Следим за hashcode
<pre><code class="java">final Object <span class="hl">theObject</span> = new Object();
final long initialHashCode = <span class="hl">theObject.hashCode()</span>;

List gcKeeper = new ArrayList();
gcKeeper.add(theObject);

long currentHashCode = initialHashCode;
while (<span class="hl">initialHashCode == currentHashCode</span>) {
    Object o = new Object();

    gcKeeper.add(o);

    currentHashCode = <span class="hl">theObject.hashCode()</span>;
}

</code></pre>
```-Xms256m -Xmx256m -XX:+UseSerialGC```

# demo

## Скрытое свойство{.native}
<pre><code class="java">package java.lang;

public class Object {

    // другие методы

    public native int hashCode();

}
</code></pre>

## Дамп объекта

![](images/header-address.svg)

Intel X86: Little Endian

## Сколько влезет в кучу ? {.heap}

<code><span class="huuge">-Xmx256m</span></code>
<pre><code class="java">
long freeMemory =
  Runtime.getRuntime().freeMemory();

<span class="right">= <span class="hl">239_942_568</span></span>

freeMemory / vm.sizeOf( new Object() )

<span class="right">= <span class="huuge hl">14_996_410</span></span>
</code></pre>

## Граница коллизий {.heapSize}

<pre><code>eden space <span class="highlight huuge">65536K</span>, 2% used
[0x000000012a700000, 0x000000012a8db400, 0x000000012e700000)
Объект перемещён: с 0x12A8109F0 -> 0x12E7200F8
</code></pre>

<pre><code class="java">
65536K / vm.sizeOf( new Object() )

= <span class="huuge hl">4_194_304</span>
</code></pre>

## пространство hashCode{.hashCode22Bit}

<div class="center">
<br/>
<span class="huuuge">32bit → 22bit</span><br/><br/>
<br/>
<code>= <span class="huge">4_194_304</span></code> <br/>
уникальных значений</div>

# hashCode → address → <br/> <span style="margin-left:200px;">→ memory allocation</span>

## Memory allocation  {.simpleAllocation}

<pre><code class="java">public interface Allocator {
    long malloc(long size);
}

class SimpleAllocator implements Allocator {
    private long memoryPointer;

    @Override
    public long malloc(long size) {
        long old = memoryPointer;
        memoryPointer += size;
        return old;
    }
}
</code></pre>

## Исправим malloc: SyncAllocator {.syncAllocation}

<pre><code class="java">class SyncAllocator implements Allocator {
    private long memoryPointer;

    @Override
    public <span class="hl">synchronized</span> long malloc(long size) {
        long old = memoryPointer;
        memoryPointer += size;
        return old;
    }
}
</code></pre>

## SyncAllocator Performance Benchmark {.syncAllocationBenchmark}
<pre><code class="java">@Benchmark @Threads( 4 )
public long syncAllocator() {
    return syncAllocator.malloc( 16 );
}</code></pre>

## SyncAllocator Performance Benchmark {.syncAllocationBenchmark}
```{r, fig.width=10, fig.height=5}
df = read.csv(file = "csv/allocations.csv", header = TRUE)
df <- subset(df, alloc == "single-threaded" | alloc == 'sync')

ggplot(data=df, aes(x=reorder(alloc, -pos), y=value, fill=alloc)) +
  geom_bar(stat="identity",  colour="#444444", alpha=0.95) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  scale_fill_manual(values=c('single-threaded'='#21bd83', 'java'='#a9a518','sync'='#fa8074', 'cas'='#00b3f6', 'tlab'='#e67bf3')) +
  geom_text(aes(label=value), hjust=-0.3, vjust=-0.4, size=5, fontface = "bold") +
  coord_flip() +
  labs(title = "sync @Threads ( 4 ), single-threaded @Threads( 1 )",
       x = "",
       y = "ns/op") +
  theme_classic() +
  scale_y_continuous(limits=c(0, max(df$value) + 30), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.position="none")
```
![](images/less-is-more.svg)

# Можно ли лучше ?

# Compare-and-Set

## CAS Allocator {.casAllocation}
<pre><code class="java">class CASAllocator implements Allocator {
    private final AtomicLong memoryPointer =
        new <span class="hl">AtomicLong</span>();

    @Override
    public long malloc(long size) {
        return memoryPointer.<span class="hl">getAndAdd</span>( size );
    }
}
</code></pre>

## Allocators Performance Benchmark {.casAllocationBenchmark}
<pre><code class="java">@Benchmark @Threads( 4 )
public long casAllocator() {
    return casAllocator.malloc( 16 );
}
</code></pre>

## Allocators Performance Benchmark {.casAllocationBenchmark}

```{r, fig.width=10, fig.height=5}
df = read.csv(file = "csv/allocations.csv", header = TRUE)
df <- subset(df, alloc == "cas" | alloc == 'sync' | alloc == "single-threaded" )

ggplot(alpha=0.3, data=df, aes(x=reorder(alloc, -pos), y=value, fill=alloc)) +
  geom_bar(stat="identity",  colour="#444444", alpha=0.95) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  scale_fill_manual(values=c('single-threaded'='#21bd83', 'java'='#a9a518','sync'='#fa8074', 'cas'='#00b3f6', 'tlab'='#e67bf3')) +
  geom_text(aes(label=value), hjust=-0.3, vjust=-0.4, size=5, fontface = "bold") +
  coord_flip() +
  labs(title = "sync/cas @Threads ( 4 ), single-threaded @Threads( 1 )",
       x = "",
       y = "ns/op") +
  theme_classic() +
  scale_y_continuous(limits=c(0, max(df$value) + 30), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.position="none")
```
![](images/less-is-more.svg)

## Java Allocation {.javaAllocation}
<pre><code class="java">@Benchmark @Threads( 4 )
public Object javaAllocation() {
    return new Object();
}
</code></pre>

## Java Allocation {.javaAllocation}

```{r, fig.width=10, fig.height=5}
df = read.csv(file = "csv/allocations.csv", header = TRUE)
df <- subset(df, alloc == "cas" | alloc == "java" | alloc == "sync" | alloc == "single-threaded")

ggplot(alpha=0.3, data=df, aes(x=reorder(alloc, -pos), y=value, fill=alloc)) +
  geom_bar(stat="identity",  colour="#444444", alpha=0.95) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  scale_fill_manual(values=c('single-threaded'='#21bd83', 'java'='#a9a518','sync'='#fa8074', 'cas'='#00b3f6', 'tlab'='#e67bf3')) +
  geom_text(aes(label=value), hjust=-0.3, vjust=-0.4, size=5, fontface = "bold") +
  coord_flip() +
  labs(title = "@Threads( 4 )",
       x = "",
       y = "ns/op") +
  theme_classic() +
  scale_y_continuous(limits=c(0, max(df$value) + 30), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.position="none")
```
![](images/less-is-more.svg)

# Можно ли ещё лучше ?

# Распеделение hashCode по нитям

## Распеделение hashCode : Ожидания

```{r, out.height="600px", out.width="1000px", echo = FALSE}
df = read.csv(file = "csv/hashCodesNoTLAB.csv", nrows = 36, header = TRUE)
min_address = min(df$address)
ggplot(data=df, mapping = aes(x = address, y = index, group=thread, colour=thread, shape=thread)) +
  geom_point(size=4) +
  theme_classic() +
  labs(
    title="количество объектов",
    x = "адреса объектов",
    y = "") +
  scale_shape_manual(values=c("thread-0"=17, "thread-1"=19, "thread-2"=15, "thread-3"=9))+
  scale_y_continuous(breaks=c(0,1,2,3,4,5,6,7,8,9,10), labels = function(n){format(n, big.mark = "_", scientific = FALSE)}, expand = c(0, 0)) +
  scale_x_continuous(breaks=c(min_address, min_address + 160, min_address + 160 * 2, min_address + 160 * 3), labels = function(n){ifelse(n == min_address,  base::sprintf("base"), base::sprintf("+ %d", as.integer(n - min_address)))}, expand = c(0, 0)) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(title = element_text(size = 16, face = "bold")) +

  theme(aspect.ratio = 0.7)
```

## Распределение hashCode по 4 нитям {.hashCode20Bit}

```{r, out.height="600px", out.width="1000px", echo = FALSE}
df = read.csv(file = "csv/hashCodes.csv", header = TRUE)
min_address = min(df$address)
ggplot(data=df, mapping = aes(x = address, y = index, group=thread, colour=thread, shape=thread)) +
  geom_point(size=1) +
  theme_classic() +
  labs(
    title="количество объектов",
    x = "адреса объектов",
    y = "") +
  geom_vline(xintercept = 809203744) +
  geom_hline(yintercept = 890552) +
  scale_shape_manual(values=c("thread-0"=17, "thread-1"=19, "thread-2"=15, "thread-3"=9))+
  scale_y_continuous(breaks=c(200000,400000,600000,800000,1000000), labels = function(n){format(n, big.mark = "_", scientific = FALSE)}, expand = c(0, 0)) +
  scale_x_continuous(breaks=c(min_address, min_address + 32 * 1024 * 1024, min_address + 64 * 1024 * 1024), labels = function(n){ifelse(n == min_address, base::sprintf("base"), base::sprintf("+ %d MB", as.integer((n - min_address) / 1024/1024)))}, expand = c(0.2, 1000)) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(title = element_text(size = 16, face = "bold")) +
  theme(aspect.ratio = 0.7)
```

## Плохая новость : 1 млн уникальных значений{.hashCode20Bit}

$$ uniqueValues = {{EdenSize} \over {sizeOf(Object) \cdot threads}} = $$
$$ = 1048576$$
$$ bits = log_2{1048576} = 20 $$

<div class="center"><span class="huuuge">22bit → 20bit</span></div>

## Хорошая новость {.hashCodeDistribution}

```{r, out.height="600px", out.width="1000px", echo = FALSE}
df = read.csv(file = "csv/hashCodes.csv", nrows = 36, header = TRUE)
min_address = min(df$address)
ggplot(data=df, mapping = aes(x = address, y = index, group=thread, colour=thread, shape=thread)) +
  geom_point(size=5) +
  theme_classic() +
  labs(
    title="количество объектов",
    x = "адреса объектов",
    y = "") +
  scale_shape_manual(values=c("thread-0"=17, "thread-1"=19, "thread-2"=15, "thread-3"=9))+
  scale_y_continuous(breaks=c(0,1,2,3,4,5,6,7,8,9,10), labels = function(n){format(n, big.mark = "_", scientific = FALSE)}, expand = c(0, 0)) +
  scale_x_continuous(breaks=c(min_address, min_address + 700 * 1024, min_address + 2 * 700 * 1024, min_address + 3 * 700 * 1024), labels = function(n){ifelse(n == min_address, base::sprintf("base"), base::sprintf("+ %d KiB", as.integer((n - min_address)/1024)))}, expand = c(0.2, 1000)) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(title = element_text(size = 16, face = "bold")) +

  theme(aspect.ratio = 0.7)
```

## Даёшь **БОЛЬШИЕ** куски памяти ! {.tlabcode}
<pre><code class="java">public class TLABLikeAllocator implements Allocator {
  private static final long <span class="hl">SIZE = 1024L * 1024L</span>;

  private final AtomicLong memoryPointer = new AtomicLong();
  private final ThreadLocal&lt;AddressHolder&gt; threadLocal =
       ThreadLocal.withInitial(() -&gt; new AddressHolder());

  public long malloc( long size ) {
    AddressHolder addressHolder = threadLocal.get();
    while( true ) {
      if (addressHolder.value + size &lt;= addressHolder.maxValue) {
          long old = addressHolder.value;
          addressHolder.value += size;
          return old;
      }

      long value = memoryPointer.getAndAdd( SIZE );
      addressHolder.value = value;
      addressHolder.maxValue = value + SIZE;
    }
  }
}
</code></pre>

## Даёшь **БОЛЬШИЕ** куски памяти ! {.tlabcode}
<pre><code class="java">public class TLABLikeAllocator implements Allocator {
  private static final long SIZE = 1024L * 1024L;

  private final AtomicLong <span class="hl">memoryPointer = new AtomicLong()</span>;
  private final ThreadLocal&lt;AddressHolder&gt; threadLocal =
       ThreadLocal.withInitial(() -&gt; new AddressHolder());

  public long malloc( long size ) {
    AddressHolder addressHolder = threadLocal.get();
    while( true ) {
      if (addressHolder.value + size &lt;= addressHolder.maxValue) {
          long old = addressHolder.value;
          addressHolder.value += size;
          return old;
      }

      long value = <span class="hl">memoryPointer.getAndAdd( SIZE )</span>;
      addressHolder.value = value;
      addressHolder.maxValue = value + SIZE;
    }
  }
}
</code></pre>

## Даёшь **БОЛЬШИЕ** куски памяти ! {.tlabcode}
<pre><code class="java">public class TLABLikeAllocator implements Allocator {
  private static final long SIZE = 1024L * 1024L;

  private final AtomicLong memoryPointer = new AtomicLong();
  private final ThreadLocal&lt;AddressHolder&gt; threadLocal =
       <span class="hl">ThreadLocal.withInitial(() -&gt; new AddressHolder())</span>;

  public long malloc( long size ) {
    AddressHolder addressHolder = threadLocal.get();
    while( true ) {
      <span class="hl">if (addressHolder.value + size &lt;= addressHolder.maxValue) {
          long old = addressHolder.value;
          addressHolder.value += size;
          return old;
      }</span>

      long value = memoryPointer.getAndAdd( SIZE );
      addressHolder.value = value;
      addressHolder.maxValue = value + SIZE;
    }
  }
}
</code></pre>
## Allocators Performance Benchmark {.tlabAllocatorBenchmark}
<pre><code class="java">@Benchmark @Threads( 4 )
public long tlabAllocator() {
    return tlabAllocator.malloc( 16 );
}</code></pre>

## Allocators Performance Benchmark {.tlabAllocatorBenchmark}
```{r, fig.width=10, fig.height=5}

df = read.csv(file = "csv/allocations.csv", header = TRUE)
df <- subset(df, alloc == "cas" | alloc == "java" | alloc == "sync" | alloc == "tlab" )

ggplot(alpha=0.3, data=df, aes(x=reorder(alloc, -pos), y=value, fill=alloc)) +
  geom_bar(stat = "identity", colour="#444444", alpha=0.95) +
  geom_text(aes(label=value), hjust=-0.3, vjust=-0.4, size=5, fontface = "bold") +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  scale_fill_manual(values=c('single-threaded'='#21bd83', 'java'='#a9a518','sync'='#fa8074', 'cas'='#00b3f6', 'tlab'='#e67bf3')) +
  coord_flip() +
  labs(title = "@Threads( 4 )",
       x = "",
       y = "ns/op") +
  theme_classic() +
  scale_y_continuous(limits=c(0, max(df$value) + 25), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.position="none")
```
![](images/less-is-more.svg)

## Thread Local Allocation Buffer

![](images/tlab.svg)

## Thread Local Allocation Buffer

![](images/tlab2.svg)

## Стоимость TLAB {.tlabAllocatorBenchmark}

<pre><code class="java">@Benchmark @Threads( 4 )
public Object allocate() {
   return new Object();
}</code></pre>

<div class="center"><span class="huuuge">-XX:<span class="highlight">+</span>UseTLAB</span> vs <span class="huuuge">-XX:<span class="highlight">-</span>UseTLAB</span></div>
## Стоимость TLAB {.tlabAllocatorBenchmark}

```{r, fig.width=10, fig.height=5}
df = read.csv(file = "csv/UseTLAB.csv", header = TRUE)
ggplot(alpha=0.3, data=df, aes(x=type, y=value, fill=type)) +
  geom_bar(stat="identity",  colour="black") +
  scale_fill_manual(values=c("-XX:-UseTLAB"='#f57670', "-XX:+UseTLAB"="#1fbec3")) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  geom_text(aes(label=value), hjust=-0.6, size=5, fontface = "bold") +
  coord_flip() +
  labs(title = "@Threads( 4 )",
       x = "",
       y = "ns/op") +
  scale_y_continuous(limits = c(0, max(df$value) + 70), expand = c(0, 0)) +
  theme_classic() +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size=16, face = "bold"))+
  theme(legend.position="none")
```
![](images/less-is-more.svg)

# <span class="huuge">32bit → 20bit</span>

# Может быть <span class="huuge">Random</span> ?

## Парадокс дней рождения {.paradox}

$$p_{uniq}(n) = \left({1 - \frac{1}{d}}\right)\cdot\left({1 - \frac{2}{d}}\right)\cdot\ldots\cdot\left({1 - \frac{n - 1}{d}}\right) = $$
$$ = \frac{d}{d^{n} \cdot (d - n)!}$$


$$ n \approx \sqrt{2  d \cdot ln({1\over{1 - p_{uniq}}}) }$$
<div class="center">при <span class="huge">$$ \ d = 2^{32}, \ p = 0.5 \Rightarrow $$</span> <span class="huuuge">$$ n \approx  77162 $$</span></div>

## -XX:hashCode {.XXhashCode}

-XX:hashCode=k | Тип
---------------|----------
  0 | <span class="good">[Park-Miller ГПСЧ](https://en.wikipedia.org/wiki/Lehmer_random_number_generator) </span>
  1 | <span class="bad">fn(адрес объекта, глобальное состояние)</span>
  2 | <span class="bad">константа 1</span>
  3 | <span class="good">последовательный счетчик</span>
  4 | <span class="huuge highlight">адрес объекта</span>
  5 | <span class="good">[Marsaglia xor-shift ГПСЧ](https://en.wikipedia.org/wiki/Xorshift)</span> _**по умолчанию** в java 8_

## Дамп объекта при -XX:hashCode=5

![](images/header.svg)

## Распределение hashCode 10 млн об-в в 10 нитях
```{r  fig.width=10.5, fig.height=6, echo = FALSE}

addressHashCode = read.csv(file = "csv/addressHashCode.csv", nrows = rows, header = TRUE)
defaultHashCode = read.csv(file = "csv/defaultHashCode.csv", nrows = rows, header = TRUE)
ggplot() +
  geom_histogram(data=addressHashCode, aes(x=hashCode, fill="address"), alpha=0.7, bins = 800) +
  geom_histogram(data=defaultHashCode, aes(x=hashCode, fill="MXSRng"), alpha=0.7, bins = 800) +
  scale_fill_manual(name="тип hashCode:", labels=c("address"="адрес", "MXSRng"="MXS-гпсч"), values=c("address" ="#003dae", "MXSRng" = "#ae003d")) +
  labs(title =
         sprintf("количество коллизий по адресу: %s k, по MXS-гпсч: %s k",
                 round( sum(duplicated(addressHashCode)) / 1000, 1),
                 round( sum(duplicated(defaultHashCode)) / 1000, 1)),
       x = "hashCode") +
  theme_classic() +
  theme(axis.title.y=element_blank()) +
  scale_y_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}, expand = c(0, 0)) +
  scale_x_continuous(labels = function(n){format(n, big.mark = "_", scientific = FALSE)}, expand = c(0, 0)) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.text.y = element_text(size = 14, face = "bold")) +
  theme(axis.text.x = element_text(size = 14, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(axis.title.x=element_text(margin=margin(t=20))) +
  theme(legend.text = element_text(size = 14, face = "bold")) +
  theme(title = element_text(size = 16, face = "bold")) +

  theme(aspect.ratio = 9/16)
```

## Вычислялся ли hashCode ?

```{r, fig.width=10, fig.height=5}

df = read.csv(file = "csv/allocations.csv", header = TRUE)
df <- subset(df, alloc == "java" | alloc == "tlab" )

ggplot(alpha=0.3, data=df, aes(x=reorder(alloc, -pos), y=value, fill=alloc)) +
  geom_bar(stat = "identity", colour="#444444", alpha=0.95) +
  geom_text(aes(label=value), hjust=-0.2, vjust=-0.7, size=5, fontface = "bold") +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  scale_fill_manual(values=c('single-threaded'='#21bd83', 'java'='#a9a518','sync'='#fa8074', 'cas'='#00b3f6', 'tlab'='#e67bf3')) +
  coord_flip() +
  labs(title = "@Threads( 4 )",
       x = "",
       y = "ns/op") +
  theme_classic() +
  scale_y_continuous(limits=c(0, max(df$value) + 4), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.position="none")
```
![](images/less-is-more.svg)

## Object.hashCode() benchmark {.objectHashCodeBenchmark}
<pre><code class="java">Object theObject = new Object();

@Benchmark @Threads( 4 )
public Object javaHashCode() {
    Object object = new Object();
    object.<span class="hl">hashCode()</span>;
    return object;
}

@Benchmark @Threads( 4 )
public Object readHashCode() {
    return <span class="hl">theObject.hashCode()</span>;
}
</code></pre>

## Object.hashCode() benchmark

```{r, fig.width=10, fig.height=5}

df = read.csv(file = "csv/allocations.csv", header = TRUE)
df <- subset(df, alloc == "java" | alloc == "javaHashCode" | alloc == "readHashCode" | alloc == "tlab" )

ggplot(alpha=0.3, data=df, aes(x=reorder(alloc, -pos), y=value, fill=alloc)) +
  geom_bar(stat = "identity", colour="#444444", alpha=0.95) +
  geom_text(aes(label=value), hjust=-0.2, vjust=-0.7, size=5, fontface = "bold") +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  scale_fill_manual(values=c('single-threaded'='#21bd83', 'java'='#a9a518','sync'='#fa8074', 'cas'='#00b3f6', 'tlab'='#e67bf3', 'javaHashCode'='#888888')) +
  coord_flip() +
  labs(title = "@Threads( 4 )",
       x = "",
       y = "ns/op") +
  theme_classic() +
  scale_y_continuous(limits=c(0, max(df$value) + 15), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size = 16, face = "bold")) +
  theme(legend.position="none")
```
![](images/less-is-more.svg)

## Дамп объекта, сразу после создания {.objectDumpRightAfterCreation}

<pre><code class="java">Object object = new Object();

dump( object );</code></pre>

![](images/header-biasedlocking0.svg)

# monitor {.nativeMonitor}
<pre><code class="java">public class Object {
  //// другие методы
  public final native void notify();

  public final native void wait(long timeout)
      throws InterruptedException;
}</code></pre>


## Biased Locking

![](images/biasedlocking.svg)

## Biased Locking demo:  {.biasedDemo}
<pre><code class="java">synchronized (object) {
    object.notifyAll();
}
dump( object );</code></pre>
![](images/header-biasedlocking1.svg)

## StringBufferPerfTest {.StringBufferPerfTestSingle}

<pre><code class="java">StringBuffer buf = new StringBuffer();

@Benchmark @Thread(1)
public String bufferToString() {
  return buf.toString();
}</code></pre>

<code><span class="highlight">-XX:+UseBiasedLocking</span></code> VS <code><span class="highlight">-XX:-UseBiasedLocking</span></code>

```
```

<code>-XX:BiasedLockingStartupDelay=0</code>

## StringBufferPerfTest {.StringBufferPerfTestSingle}

<pre><code class="java">StringBuffer buf = new StringBuffer();

@Benchmark @Thread(1)
public String bufferToString() {
  return buf.toString();
}</code></pre>

<code>-XX:+UseBiasedLocking</code> VS <code>-XX:-UseBiasedLocking</code>

```
```

<code><span class="highlight">-XX:BiasedLockingStartupDelay=0</span></code>


## StringBufferPerfTest результаты

```{r, fig.width=10, fig.height=5}
df = read.csv(file = "csv/StringBufferPerfTest.csv", header = TRUE)

df <- subset(df, type == "-XX:+UseBiasedLocking" | type == "-XX:-UseBiasedLocking" )

ggplot(alpha=0.3, data=df, aes(x=type, y=value, fill=type)) +
  geom_bar(stat="identity",  colour="black") +
  scale_fill_manual(values=c('-XX:+UseBiasedLocking'='#1fbec3', '-XX:-UseBiasedLocking'='#f57670')) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  geom_text(aes(label=value), hjust=-0.2, vjust=-0.7, size=5, fontface = "bold") +
  coord_flip() +
  theme_classic() +
  labs(title = "@Threads( 1 )",
       x = "",
       y = "ns/op") +
  scale_y_continuous(limits=c(0,max(df$value)+5), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size=16, face = "bold"))+
  theme(legend.position="none")
```
![](images/less-is-more.svg)

## identityHashCode

<pre><code class="java">StringBuffer buf = new StringBuffer();
StringBuffer <span class="hl">bufferWithIdHashCode</span> = 
    new StringBuffer();

@Setup
public void setup(Blackhole bh) {
    bh.consume( System.identityHashCode(
        bufferWithIdHashCode ) );
}

@Benchmark  @Thread(1)
public String bufferWithIdHashCode() {
  return <span class="hl">bufferWithIdHashCode</span>.toString();
}

@Benchmark @Thread(1)
public String buffer() {
  return buf.toString();
}</code></pre>

## identityHashCode

<pre><code class="java">StringBuffer buf = new StringBuffer();
StringBuffer bufferWithIdHashCode = 
   new StringBuffer();

@Setup
public void setup(Blackhole bh) {
    bh.consume( <span class="hl">System.identityHashCode(
        bufferWithIdHashCode )</span> );
}

@Benchmark  @Thread(1)
public String bufferWithIdHashCode() {
  return bufferWithIdHashCode.toString();
}

@Benchmark  @Thread(1)
public String buffer() {
  return buf.toString();
}</code></pre>

## identityHashCode результаты

```{r, fig.width=10, fig.height=5}
df = read.csv(file = "csv/StringBufferPerfTest.csv", header = TRUE)

df <- subset(df, type == "buffer -XX:-UseBiasedLocking" | type == 'buffer' | type == 'bufferWithIdHashCode')

ggplot(alpha=0.7, data=df, aes(x=reorder(type, -pos), y=value, fill=type)) +
  geom_bar(stat="identity",  colour="black") +
  scale_fill_manual(values=c('buffer -XX:-UseBiasedLocking'='#fa8074', 'buffer'='#21bd83', 'bufferWithIdHashCode'='#e67bf3')) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error),  width=.5, position=position_dodge(0.5)) +
  geom_text(aes(label=value), hjust=-0.2, vjust=-0.7, size=5, fontface = "bold") +
  coord_flip() +
  theme_classic() +
  labs(title = "@Threads( 1 )",
       x = "",
       y = "ns/op") +
  scale_y_continuous(limits=c(0,max(df$value)+5), expand = c(0, 0)) +
  theme(axis.text.y = element_text(size = 16, face = "bold")) +
  theme(axis.title = element_text(size=16, face = "bold"))+
  theme(legend.position="none")
```
![](images/less-is-more.svg)

## Revoke Biased Locking:  {.biasedDemo}

<pre><code class="java">int idHashCode
  = System.identityHashCode( object );

dump( object );</code></pre>
![](images/header-biasedlocking2.svg)

## Заключение {.conclusion}

* <span class="good">Hash-структуры</span>  - быстро
* <span class="good">Переопределяйте `hashCode` и `equals`</span>
    + и ещё лучше <span class="good">определяйте `compareTo`</span>
    + исследуйте свои hash-функции
* hashCode - не <span class="bad">адрес</span>
    + <span class="good">GC</span>, <span class="good">TLAB</span>, не злоупотребляйте <span class="bad">`identityHashCode`</span>
* **Meten is weten** (голл.) &laquo;Измерение - знание&raquo;

# Контакты {.contacts}

### слайды и примеры: [github.com/vladimirdolzhenko/hashCodeLegend](https://github.com/vladimirdolzhenko/hashCodeLegend)
### email: [vladimir.dolzhenko@gmail.com](mailto:vladimir.dolzhenko@gmail.com)
### twitter: [\@dolzhenko](https://twitter.com/dolzhenko)


<div class="thanks">спасибо: [\@VladimirSitnikv](https://twitter.com/VladimirSitnikv)  [\@dj_begemot](https://twitter.com/dj_begemot)  [\@AndreiPangin](https://twitter.com/AndreiPangin) [\@gvsmirnov](https://twitter.com/gvsmirnov) [\@i_sopov](https://twitter.com/i_sopov)</div>

